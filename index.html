<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>rhiz0m</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0705;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
  }
  canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  #ui {
    position: absolute;
    pointer-events: none;
    width: 100%;
    height: 100%;
    z-index: 10;
  }
  #title-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
  }
  #title {
    font-family: 'VT323', monospace;
    font-size: clamp(52px, 9vw, 110px);
    color: #b8d4a0;
    letter-spacing: 0.18em;
    text-shadow:
      0 0 18px rgba(120, 200, 80, 0.7),
      0 0 55px rgba(80, 160, 40, 0.3),
      2px 2px 0px #1a2e10;
    opacity: 0;
    transition: opacity 2.5s ease;
  }
  #subtitle {
    font-family: 'VT323', monospace;
    font-size: clamp(13px, 1.8vw, 20px);
    color: #4a6630;
    letter-spacing: 0.35em;
    margin-top: 2px;
    opacity: 0;
    transition: opacity 2s ease 1.2s;
  }
</style>
</head>
<body>
<canvas id="bgC"></canvas>
<canvas id="rootC"></canvas>
<canvas id="topC"></canvas>
<div id="ui">
  <div id="title-wrap">
    <div id="title">rhiz0m</div>
    <div id="subtitle">no servers. no accounts. just math.</div>
  </div>
</div>

<script>
// ── Setup ─────────────────────────────────────────────────────────────────────
const bgC   = document.getElementById('bgC');
const rootC = document.getElementById('rootC');
const topC  = document.getElementById('topC');
const bgX   = bgC.getContext('2d');
const rootX = rootC.getContext('2d');
const topX  = topC.getContext('2d');

let W, H, groundY;
let gPts = [], rocks = [];
let mouse = { x: 0, y: 0 };

function setSize() {
  W = window.innerWidth;
  H = window.innerHeight;
  groundY = Math.floor(H * 0.47);
  mouse.x = W / 2; mouse.y = H * 0.75;
  [bgC, rootC, topC].forEach(c => { c.width = W; c.height = H; });
}

// ── Ground profile ────────────────────────────────────────────────────────────
function buildGround() {
  gPts = [];
  const seg = 100;
  for (let i = 0; i <= seg; i++) {
    const x = (i / seg) * W;
    const n = Math.sin(i * 0.55) * 11 + Math.sin(i * 1.35) * 6 + Math.sin(i * 3.2) * 3;
    gPts.push({ x, y: groundY + n });
  }
}
function gAt(x) {
  for (let i = 0; i < gPts.length - 1; i++) {
    if (x >= gPts[i].x && x <= gPts[i + 1].x) {
      const t = (x - gPts[i].x) / (gPts[i + 1].x - gPts[i].x);
      return gPts[i].y + t * (gPts[i + 1].y - gPts[i].y);
    }
  }
  return groundY;
}

// ── Rocks ─────────────────────────────────────────────────────────────────────
function buildRocks() {
  rocks = [];
  for (let i = 0; i < 32; i++) {
    const x = 20 + Math.random() * (W - 40);
    const depth = Math.pow(Math.random(), 0.7);
    const y = groundY + 28 + depth * (H - groundY - 60);
    const rx = 7 + Math.random() * 32;
    const ry = 5 + Math.random() * 18;
    const rot = Math.random() * Math.PI;
    const s = Math.floor(18 + depth * 18);
    rocks.push({ x, y, rx, ry, rot, s });
  }
}

// ── Static background ─────────────────────────────────────────────────────────
function drawBG() {
  bgX.clearRect(0, 0, W, H);

  // Sky — fiery orange haze
  const skyG = bgX.createLinearGradient(0, 0, 0, groundY + 30);
  skyG.addColorStop(0,    '#080300');
  skyG.addColorStop(0.25, '#200a00');
  skyG.addColorStop(0.65, '#561800');
  skyG.addColorStop(1,    '#8c3600');
  bgX.fillStyle = skyG;
  bgX.fillRect(0, 0, W, groundY + 30);

  // Haze blobs
  [[0.15, 0.4, 0.18], [0.45, 0.55, 0.22], [0.78, 0.3, 0.16],
   [0.3, 0.7, 0.14],  [0.65, 0.75, 0.12]].forEach(([fx, fy, a]) => {
    const hx = fx * W, hy = fy * groundY;
    const r  = 100 + fx * 200;
    const g  = bgX.createRadialGradient(hx, hy, 0, hx, hy, r);
    g.addColorStop(0, `rgba(200,65,0,${a})`);
    g.addColorStop(1, `rgba(200,65,0,0)`);
    bgX.fillStyle = g;
    bgX.fillRect(hx - r, hy - r, r * 2, r * 2);
  });

  // Static ember dots in sky
  for (let i = 0; i < 60; i++) {
    const ex = Math.random() * W, ey = Math.random() * groundY;
    bgX.beginPath();
    bgX.arc(ex, ey, 0.5 + Math.random() * 1.5, 0, Math.PI * 2);
    bgX.fillStyle = `rgba(255,${80 + Math.floor(Math.random()*120)},0,${0.1 + Math.random() * 0.45})`;
    bgX.fill();
  }

  // Underground soil
  const soilG = bgX.createLinearGradient(0, groundY, 0, H);
  soilG.addColorStop(0,   '#1a0e05');
  soilG.addColorStop(0.4, '#0f0903');
  soilG.addColorStop(1,   '#070503');
  bgX.fillStyle = soilG;
  bgX.beginPath();
  bgX.moveTo(0, H);
  bgX.lineTo(0, gPts[0].y);
  gPts.forEach(p => bgX.lineTo(p.x, p.y));
  bgX.lineTo(W, H);
  bgX.closePath();
  bgX.fill();

  // Ground edge
  bgX.beginPath();
  bgX.moveTo(gPts[0].x, gPts[0].y);
  gPts.forEach(p => bgX.lineTo(p.x, p.y));
  bgX.strokeStyle = 'rgba(130,65,10,0.85)';
  bgX.lineWidth = 2.5;
  bgX.stroke();

  // Rocks
  rocks.forEach(r => {
    bgX.save();
    bgX.translate(r.x, r.y);
    bgX.rotate(r.rot);
    const rg = bgX.createRadialGradient(-r.rx * 0.25, -r.ry * 0.25, 0, 0, 0, Math.max(r.rx, r.ry));
    const s = r.s;
    rg.addColorStop(0, `rgb(${s + 20},${s + 12},${s + 6})`);
    rg.addColorStop(1, `rgb(${s},${Math.floor(s * 0.7)},${Math.floor(s * 0.5)})`);
    bgX.fillStyle = rg;
    bgX.beginPath();
    bgX.ellipse(0, 0, r.rx, r.ry, 0, 0, Math.PI * 2);
    bgX.fill();
    bgX.strokeStyle = 'rgba(0,0,0,0.35)';
    bgX.lineWidth = 1;
    bgX.stroke();
    bgX.restore();
  });

  // Soil texture
  for (let i = 0; i < 400; i++) {
    const tx = Math.random() * W;
    const ty = groundY + 15 + Math.random() * (H - groundY - 15);
    bgX.beginPath();
    bgX.arc(tx, ty, 0.4 + Math.random() * 0.8, 0, Math.PI * 2);
    bgX.fillStyle = `rgba(55,30,8,${0.08 + Math.random() * 0.18})`;
    bgX.fill();
  }
}

// ── CA Root System ────────────────────────────────────────────────────────────
// TIME-BASED browning: new segments are always drawn bright green.
// Each CA tick we composite a faint brown wash over the entire rootC canvas,
// so older deposits gradually brown while fresh green segments stay vivid.

const CA_TICK    = 900;
const BASE_NODES = 22;
const MAX_AGE    = 55;
const FRESH_GREEN = [38, 175, 22];   // rgb of a brand-new segment tip

let nodes = [];
let leafSprites = [];

function spawnNode(x, y, age, isOrigin) {
  if (x === undefined) {
    x = W * 0.05 + Math.random() * W * 0.9;
    y = gAt(x) + 4 + Math.random() * 28;
    age = 0;
    isOrigin = true;
  }
  nodes.push({ x, y, age: age || 0, isOrigin: !!isOrigin });
  if (isOrigin) leafSprites.push({ x, y: gAt(x) });
}

function initNodes() {
  nodes = []; leafSprites = [];
  for (let i = 0; i < BASE_NODES; i++) spawnNode();
}

function ageRootCanvas() {
  // Composite a very faint soil-brown over all existing root pixels.
  // source-atop only touches pixels with existing alpha > 0.
  rootX.save();
  rootX.globalCompositeOperation = 'source-atop';
  rootX.fillStyle = 'rgba(101, 52, 14, 0.032)';
  rootX.fillRect(0, 0, W, H);
  rootX.globalCompositeOperation = 'source-over';
  rootX.restore();
}

function caStep() {
  // First: age everything already drawn (shift green → brown over time)
  ageRootCanvas();

  const snap = [...nodes];
  snap.forEach(node => {
    if (node.age >= MAX_AGE) return;

    const others = nodes.filter(n => n !== node);
    if (!others.length) return;
    const nb = others[Math.floor(Math.random() * others.length)];

    const mdx = mouse.x - node.x, mdy = mouse.y - node.y;
    const ml  = Math.sqrt(mdx * mdx + mdy * mdy) || 1;
    const ndx = nb.x - node.x,   ndy = nb.y - node.y;
    const nl  = Math.sqrt(ndx * ndx + ndy * ndy) || 1;

    // More lateral: 40% neighbour, 25% mouse, 15% down, 20% jitter
    let dx = (mdx / ml) * 0.25 + (ndx / nl) * 0.40 + (Math.random() - 0.5) * 0.35;
    let dy = (mdy / ml) * 0.15 + (ndy / nl) * 0.25 + 0.15 + (Math.random() - 0.5) * 0.25;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    dx /= len; dy /= len;

    const step = 7 + Math.random() * 14;
    let nx = Math.max(4, Math.min(W - 4, node.x + dx * step));
    let ny = Math.max(gAt(nx) + 3, Math.min(H - 6, node.y + dy * step));

    // Always draw new segments in fresh bright green
    const [fr, fg, fb] = FRESH_GREEN;
    const alpha = 0.6 + Math.random() * 0.28;
    const thick = Math.max(0.6, 2.9 - node.age * 0.035);

    rootX.beginPath();
    rootX.moveTo(node.x, node.y);
    rootX.lineTo(nx, ny);
    rootX.lineWidth = thick;
    rootX.strokeStyle = `rgba(${fr},${fg},${fb},${alpha})`;
    rootX.lineCap = 'round';
    rootX.shadowColor = `rgba(${fr},${Math.min(255, fg + 30)},${fb},0.25)`;
    rootX.shadowBlur = 4;
    rootX.stroke();
    rootX.shadowBlur = 0;

    rootX.beginPath();
    rootX.arc(nx, ny, thick * 0.9, 0, Math.PI * 2);
    rootX.fillStyle = `rgba(${fr},${Math.min(255, fg + 20)},${fb},${alpha * 0.85})`;
    rootX.fill();

    node.x = nx; node.y = ny; node.age++;

    if (node.age > 5 && Math.random() < 0.09 && nodes.length < 65) {
      spawnNode(nx, ny, node.age, false);
    }
  });

  nodes = nodes.filter(n => n.age < MAX_AGE);
  while (nodes.length < BASE_NODES) spawnNode();
}

initNodes();
// Run several steps immediately so roots are visible from the start
for (let i = 0; i < 18; i++) caStep();
setInterval(caStep, CA_TICK);

// ── Leaf sprites ──────────────────────────────────────────────────────────────
function drawLeaf(ctx, x, y, angle, size, alpha) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.globalAlpha = alpha;

  // Brown stalk
  ctx.beginPath();
  ctx.moveTo(0, 2);
  ctx.lineTo(0, -size * 0.7);
  ctx.strokeStyle = '#6b3f12';
  ctx.lineWidth = 2.2;
  ctx.stroke();

  // Leaf body
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.7);
  ctx.bezierCurveTo( size * 1.1, -size * 1.6,  size * 1.2, -size * 3.0, 0, -size * 3.5);
  ctx.bezierCurveTo(-size * 1.2, -size * 3.0, -size * 1.1, -size * 1.6, 0, -size * 0.7);
  ctx.fillStyle = '#4da822';
  ctx.shadowColor = 'rgba(60,160,20,0.45)';
  ctx.shadowBlur = 6;
  ctx.fill();

  // Midrib vein
  ctx.beginPath();
  ctx.moveTo(0, -size * 0.7);
  ctx.lineTo(0, -size * 3.3);
  ctx.strokeStyle = 'rgba(25,75,8,0.65)';
  ctx.lineWidth = 1.0;
  ctx.shadowBlur = 0;
  ctx.stroke();

  // Side veins
  for (let v = 1; v <= 3; v++) {
    const vy = -size * (0.7 + v * 0.7);
    const vx = size * 0.7;
    ctx.beginPath();
    ctx.moveTo(0, vy);
    ctx.lineTo( vx, vy - size * 0.3);
    ctx.moveTo(0, vy);
    ctx.lineTo(-vx, vy - size * 0.3);
    ctx.strokeStyle = 'rgba(25,75,8,0.35)';
    ctx.lineWidth = 0.6;
    ctx.stroke();
  }

  ctx.restore();
}

// ── Shared explosion pool ─────────────────────────────────────────────────────
const explosions = [];

function addExplosion(x, y) {
  explosions.push({
    x, y, life: 0, maxLife: 50,
    particles: Array.from({ length: 22 }, () => ({
      vx: (Math.random() - 0.5) * 6,
      vy: -(1.5 + Math.random() * 5),
      r:  1.5 + Math.random() * 3.5
    }))
  });
}

function drawExplosions(ctx) {
  explosions.forEach(ex => {
    ex.life++;
    const t = ex.life / ex.maxLife;
    const outerR = 6 + t * 40;

    const blastG = ctx.createRadialGradient(ex.x, ex.y - outerR * 0.3, 0, ex.x, ex.y, outerR);
    blastG.addColorStop(0,   `rgba(255,245,120,${0.95 * (1 - t)})`);
    blastG.addColorStop(0.3, `rgba(255,150,0,${0.75 * (1 - t)})`);
    blastG.addColorStop(0.7, `rgba(210,40,0,${0.45 * (1 - t)})`);
    blastG.addColorStop(1,   `rgba(80,20,0,0)`);
    ctx.fillStyle = blastG;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, outerR, 0, Math.PI * 2);
    ctx.fill();

    if (t > 0.25) {
      ctx.beginPath();
      ctx.arc(ex.x, ex.y - t * 22, outerR * 0.55, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(70,55,35,${0.35 * (1 - t)})`;
      ctx.lineWidth = 5 + t * 9;
      ctx.stroke();
    }

    ex.particles.forEach(p => {
      const px = ex.x + p.vx * ex.life;
      const py = ex.y + p.vy * ex.life + 0.09 * ex.life * ex.life;
      ctx.beginPath();
      ctx.arc(px, py, Math.max(0.3, p.r * (1 - t)), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${180 + Math.floor(t * 70)},${Math.max(0, 85 - Math.floor(t * 70))},0,${1 - t})`;
      ctx.fill();
    });
  });
  for (let i = explosions.length - 1; i >= 0; i--) {
    if (explosions[i].life >= explosions[i].maxLife) explosions.splice(i, 1);
  }
}

// ── Artillery class (shoots toward a target x) ───────────────────────────────
class Artillery {
  constructor(fx, facing) {
    this.fx     = fx;      // fractional x position (0–1)
    this.facing = facing;  // +1 = shoots right, -1 = shoots left
    this.shells = [];
    this.reloadTimer = Math.floor(Math.random() * 200);
    this.reloadDelay = 160 + Math.floor(Math.random() * 220);
    this.barrelAngle = facing > 0 ? -Math.PI * 0.32 : -Math.PI * 0.68;
    this.targets = []; // will be set after all guns created
  }

  get x() { return this.fx * W; }
  get y() { return gAt(this.x); }

  fire() {
    // Pick a random enemy target
    const tgt = this.targets[Math.floor(Math.random() * this.targets.length)];
    const tx  = tgt ? tgt.x : (this.facing > 0 ? W * 0.8 : W * 0.2);

    const hdx  = tx - this.x;                      // horizontal distance to target
    const dist = Math.abs(hdx);

    // Scale loft and speed to distance so shells actually reach the other side.
    // Gravity is 0.12px/frame². For a shell to travel dist px horizontally
    // at launch angle θ, rough ballistic range = v²·sin(2θ)/g.
    // We want range ≈ dist * (0.8 + random*0.4) — a band around the target.
    const rangeFrac = 0.75 + Math.random() * 0.5;  // 75%–125% of distance
    const targetRange = dist * rangeFrac;
    const g = 0.12;
    // At 45° launch sin(2θ)=1, so v = sqrt(range * g)
    const speed = Math.sqrt(targetRange * g) * (0.9 + Math.random() * 0.2);

    // Loft proportional to distance so arc height scales nicely
    const loft = -(dist * 0.40 + 40);

    let angle = Math.atan2(loft, hdx);

    if (this.facing > 0) {
      angle = Math.max(-Math.PI * 0.85, Math.min(-0.17, angle));
    } else {
      angle = Math.max(-Math.PI + 0.17, Math.min(-Math.PI * 0.55, angle));
    }

    this.barrelAngle = angle;
    this.shells.push({
      x:   this.x + Math.cos(angle) * 22,
      y:   this.y + Math.sin(angle) * 22,
      vx:  Math.cos(angle) * speed,
      vy:  Math.sin(angle) * speed,
      life: 0, dead: false
    });
  }

  drawBody(ctx) {
    const x = this.x, y = this.y, p = 4;
    const f = this.facing; // mirror for left-facing guns

    // Wheels
    ctx.fillStyle = '#3a2a10';
    [-1, 1].forEach(side => {
      ctx.beginPath(); ctx.arc(x + side * p * 2, y, p * 1.6, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#1a1005'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(x + side * p * 2, y, p * 1.6, 0, Math.PI * 2); ctx.stroke();
    });
    // Hubcaps
    ctx.fillStyle = '#5a3a18';
    [-1, 1].forEach(side => {
      ctx.beginPath(); ctx.arc(x + side * p * 2, y, p * 0.6, 0, Math.PI * 2); ctx.fill();
    });

    // Body
    ctx.fillStyle = '#5a4010';
    ctx.fillRect(x - p * 3, y - p * 2.2, p * 6, p * 2.2);
    ctx.fillStyle = '#4a3208';
    ctx.fillRect(x - p * 2.5, y - p * 3.2, p * 5, p * 1.2);

    // Barrel
    ctx.save();
    ctx.translate(x, y - p * 2.8);
    ctx.rotate(this.barrelAngle);
    const bDir = 1; // always draw barrel extending in angle direction
    ctx.fillStyle = '#6a5018';
    ctx.fillRect(0, -p * 0.65, p * 5.5, p * 1.3);
    ctx.fillStyle = '#3a2808';
    ctx.fillRect(p * 4.5, -p * 0.75, p * 1.6, p * 1.5);
    ctx.restore();
  }

  update() {
    this.reloadTimer++;
    if (this.reloadTimer >= this.reloadDelay) {
      this.reloadTimer = 0;
      this.reloadDelay = 160 + Math.floor(Math.random() * 220);
      this.fire();
    }

    this.shells.forEach(s => {
      if (s.dead) return;
      s.vy += 0.12;
      s.x  += s.vx; s.y += s.vy; s.life++;
      if (s.y >= gAt(s.x) && s.life > 30 || s.x < -20 || s.x > W + 20 || s.life > 400) {
        addExplosion(s.x, Math.min(s.y, gAt(s.x)));
        s.dead = true;
      }
    });
    this.shells = this.shells.filter(s => !s.dead);
  }

  drawShells(ctx) {
    this.shells.forEach(s => {
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(Math.atan2(s.vy, s.vx));
      ctx.fillStyle = '#cc8800';
      ctx.fillRect(-5, -2.5, 10, 5);
      ctx.fillStyle = '#ffdd55';
      ctx.fillRect(-3, -1.5, 5, 3);
      ctx.restore();
    });
  }
}

// Spawn 2–3 guns per side
function makeGuns() {
  const leftCount  = 2 + Math.floor(Math.random() * 2);  // 2 or 3
  const rightCount = 2 + Math.floor(Math.random() * 2);

  const leftGuns  = Array.from({ length: leftCount },  (_, i) =>
    new Artillery(0.04 + i * 0.10, +1)   // left side shoots right
  );
  const rightGuns = Array.from({ length: rightCount }, (_, i) =>
    new Artillery(0.96 - i * 0.10, -1)   // right side shoots left
  );

  // Cross-assign targets
  leftGuns.forEach(g  => { g.targets = rightGuns; });
  rightGuns.forEach(g => { g.targets = leftGuns;  });

  return [...leftGuns, ...rightGuns];
}

const allGuns = makeGuns();

// ── Fire sprites ──────────────────────────────────────────────────────────────
const FIRE_FRACS = [0.07, 0.22, 0.42, 0.58, 0.78, 0.93];
class Fire {
  constructor(frac) {
    this.frac = frac;
    this.t    = Math.random() * Math.PI * 2;
    this.ft   = Math.random() * Math.PI * 2;
    this.spd  = 0.020 + Math.random() * 0.016;
    this.fspd = 0.11  + Math.random() * 0.09;
    this.bob  = 3 + Math.random() * 5;
    this.px   = 4;
    // [col, row, w, h, hue_offset]
    this.map  = [
      [0,0,3,1,  0], [0,1,3,1,  5],
      [0,2,2,1, 10], [1,2,2,1,  0],
      [1,3,2,1, 15], [0,3,1,1, 10],
      [1,4,1,1, 20], [1,5,1,1, 25],
    ];
  }
  draw() {
    this.t  += this.spd;
    this.ft += this.fspd;
    const x   = this.frac * W;
    const gy  = gAt(x);
    const by  = Math.sin(this.t) * this.bob;
    const fl  = Math.sin(this.ft) * 0.28 + Math.sin(this.ft * 2.1) * 0.14;
    const px  = this.px;
    const bx  = x - px * 1.5;
    const bot = gy - px * 7 + by;
    this.map.forEach(([c, r, pw, ph, hs]) => {
      if (Math.random() < 0.07) return;
      const hue = 16 + hs;
      const a   = Math.max(0.2, Math.min(1, 0.78 + fl));
      topX.fillStyle    = `hsla(${hue},96%,${46 + hs}%,${a})`;
      topX.shadowColor  = `hsl(${hue},100%,52%)`;
      topX.shadowBlur   = 10;
      topX.fillRect(bx + c * px, bot + (6 - r - ph) * px, pw * px, ph * px);
    });
    topX.shadowBlur = 0;
    // Ground glow
    const grd = topX.createRadialGradient(x, gy, 0, x, gy, 36);
    grd.addColorStop(0, 'rgba(255,90,0,0.20)');
    grd.addColorStop(1, 'rgba(255,90,0,0)');
    topX.fillStyle = grd;
    topX.fillRect(x - 36, gy - 8, 72, 20);
  }
}
const fires = FIRE_FRACS.map(f => new Fire(f));

// ── Animated embers ───────────────────────────────────────────────────────────
let embers = Array.from({ length: 40 }, () => ({
  x: Math.random() * (typeof W !== 'undefined' ? W : 800),
  y: Math.random() * (typeof groundY !== 'undefined' ? groundY : 300),
  vx: (Math.random() - 0.5) * 0.4,
  vy: -(0.25 + Math.random() * 0.65),
  r:  0.5 + Math.random() * 1.5,
  a:  0.1  + Math.random() * 0.5,
  life: Math.random()
}));

function tickEmbers() {
  embers.forEach(e => {
    e.x += e.vx; e.y += e.vy; e.life += 0.005;
    if (e.y < 0 || e.life > 1) {
      Object.assign(e, {
        x: Math.random() * W, y: groundY - 5, life: 0,
        vy: -(0.25 + Math.random() * 0.65),
        vx: (Math.random() - 0.5) * 0.4
      });
    }
  });
}

// ── Mouse ─────────────────────────────────────────────────────────────────────
document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
document.addEventListener('touchmove', e => {
  mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY;
}, { passive: true });

// ── Title ─────────────────────────────────────────────────────────────────────
function positionTitle() {
  const el = document.getElementById('title-wrap');
  el.style.top = (groundY + H) / 2 - 50 + 'px';
}

// ── Init ──────────────────────────────────────────────────────────────────────
setSize();
buildGround();
buildRocks();
drawBG();
positionTitle();

setTimeout(() => {
  document.getElementById('title').style.opacity = '1';
  document.getElementById('subtitle').style.opacity = '1';
}, 1000);

window.addEventListener('resize', () => {
  setSize();
  buildGround();
  buildRocks();
  drawBG();
  rootX.clearRect(0, 0, W, H);
  initNodes();
  positionTitle();
  // reposition guns fractionally — they read W dynamically via getter
  embers.forEach(e => { e.x = Math.random() * W; e.y = Math.random() * groundY; });
});

// ── Main animation loop ───────────────────────────────────────────────────────
function loop() {
  topX.clearRect(0, 0, W, H);

  // Animated embers in sky
  tickEmbers();
  embers.forEach(e => {
    const fade = Math.sin(e.life * Math.PI);
    topX.beginPath();
    topX.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    topX.fillStyle = `rgba(255,${80 + Math.floor(e.life * 130)},0,${e.a * fade})`;
    topX.fill();
  });

  // Fires first (behind everything)
  fires.forEach(f => f.draw());

  // Leaf sprites — bigger (size 10), brown stalk
  leafSprites.forEach((lf, i) => {
    const wobble = Math.sin(Date.now() * 0.0008 + i * 1.7) * 0.10;
    drawLeaf(topX, lf.x, lf.y, -Math.PI * 0.5 + wobble, 10, 0.88);
  });

  // Artillery: shells + explosions + bodies on top of fires
  allGuns.forEach(g => g.update());
  allGuns.forEach(g => g.drawShells(topX));
  drawExplosions(topX);
  allGuns.forEach(g => g.drawBody(topX));

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
